## Wilson's Maze
Creates a perfect maze using Wilson's Algorithm. Utilizes JavaScript, HTML5 canvas and D3.js for DOM manipulation.


### Mazes
There are many variations and ways to draw a maze. A subset of mazes called 'perfect' mazes, are defined as those that have no loops or closed circuits and no enclosed areas.


However, perfect maze generation algorithms are not all equal. Several characteristics that differentiate them include the algorithm type, the memory and time that it requires, whether it is bias-free and uniformity.


This simulation uses Wilson's Algorithm, a tree type algorithm that is one of the few ways to create a bias free and uniform maze.


<img src="https://cloud.githubusercontent.com/assets/15305961/18558807/5b0876a8-7b29-11e6-924d-1e5f0bda3284.png">
<br><br>


### Implementation Details
##### Render
The D3.js `timer` method is used to dynamically render the maze while it is being generated by the algorithm. A max speed and incrementor is incorporated in order to adjust the speed at which the maze is rendered.


```
const speed = document.getElementById('speedSlider').value;
  const t = d3.timer(() => {
    for (let i = 0; i < speed; ++i) {
      if (randomWalk()) {
        if (remainingCells.length === 0) {
          t.stop();
          colorMaze(cells, context);
        }
        return true;
      }
    }
  });
```
<br><br>




##### Calculating the random walk
A cell not already part of the maze is selected to begin the random walk from an array of remaining cells. A random direction is then chosen for the branch to traverse. Additionally, the path of the random walk is recorded in order for Wilson's Algorithm to retrace and either append the branch to the maze or erase the section of the branch.


```
let index1;
if (index0 == null) {
  do {
    if ((index0 = remainingCells.shift()) == null) {
      return true;
    }
  } while (cells[index0] >= 0);
  previous[index0] = index0;
  drawCell(index0);
  x0 = index0 % cellSize;
  y0 = index0 / cellSize | 0;
}
```


<img src="https://cloud.githubusercontent.com/assets/15305961/18558905/cadc0210-7b29-11e6-8a17-006158dbb114.png">
<br><br><br>




##### Erasing the random walk
If the random walk encounters itself, the branch section from the collision cell to the end must be erased. The random walk then continues from the end of the collision cell. Canvas `globalCompositeOperation` is used to save the current snapshot of the maze and random walk. The section of the random walk is then drawn over to erase from the current snapshot.


```
function eraseWalk(index0, index2) {
  let index1;
  context.save();
  context.globalCompositeOperation = 'destination-out';
  do {
    index1 = previous[index0];
    if (index1 === index0 - 1) drawRight(index1);
    else if (index1 === index0 + 1) drawRight(index0);
    else if (index1 === index0 - cellSize) drawBelow(index1);
    else drawBelow(index0);
    drawCell(index0);
    previous[index0] = NaN;
    index0 = index1;
  } while (index1 !== index2);
  context.restore();
}
```
<br><br>




##### Calculating gradient fill
After the maze is created, the uniform spanning tree that Wilson's Algorithm generated is colored filled using the selected 2-color gradient. The fill logic takes the cells array of the generated maze to retrace with a color fill. The color space is mapped using `D3.rgb`.


```
context.fillStyle = d3.rgb(
  (colorOne.r + ((distance % 255) * ((colorTwo.r - colorOne.r) / 255))),
  (colorOne.g + ((distance % 255) * ((colorTwo.g - colorOne.g) / 255))),
  (colorOne.b + ((distance % 255) * ((colorTwo.b - colorOne.b) / 255)))
);
```
<img src="https://cloud.githubusercontent.com/assets/15305961/18558911/cde73efc-7b29-11e6-8e5b-7c8d647121f7.png">


